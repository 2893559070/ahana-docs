import{_ as n,o as s,c as a,a as t}from"./app-676abf65.js";const e={},c=t(`<h1 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><ul><li>方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</li><li>当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</li></ul><h2 id="代码格式" tabindex="-1"><a class="header-anchor" href="#代码格式" aria-hidden="true">#</a> 代码格式</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//研发部员工 </span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Developer</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//抽象函数。需要abstract修饰，并分号;结束</span>
<span class="token punctuation">}</span>

<span class="token comment">//JavaEE工程师</span>
<span class="token keyword">class</span> <span class="token class-name">JavaEE</span> <span class="token keyword">extends</span> <span class="token class-name">Developer</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在研发淘宝网站&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//Android工程师</span>
<span class="token keyword">class</span> <span class="token class-name">Android</span> <span class="token keyword">extends</span> <span class="token class-name">Developer</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在研发淘宝手机客户端软件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ul><li>抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。</li><li>抽象类不可以直接创建对象，原因：调用抽象方法没有意义。</li><li>只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。</li><li>之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。</li></ul><h2 id="细节问题" tabindex="-1"><a class="header-anchor" href="#细节问题" aria-hidden="true">#</a> 细节问题</h2><ul><li>抽象类一定是个父类？ 是的，因为不断抽取而来的。</li><li>抽象类中是否可以不定义抽象方法。 是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用</li><li>抽象关键字abstract不可以和哪些关键字共存？ <ul><li>private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。</li><li>final 如果引用为基本数据类型，则该引用为常量，该值无法修改；类似 <code>js const</code></li><li>static 修饰成员方法。相比于修饰成员属性，修饰成员方法对于数据的存储上面并没有多大的变化，因为我们从上面可以看出，方法本来就是存放在类的定义当中的。static修饰成员方法最大的作用，就是可以使用&quot;类名.方法名&quot;的方式操作方法，避免了先要new出对象的繁琐和资源消耗</li></ul></li></ul>`,9),l=[c];function i(p,o){return s(),a("div",null,l)}const d=n(e,[["render",i],["__file","抽象类.html.vue"]]);export{d as default};
