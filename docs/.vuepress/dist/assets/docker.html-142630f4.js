import{_ as t,r as c,o as d,c as u,b as e,d as l,e as n,w as r,a as s}from"./app-676abf65.js";const p={},h=e("h1",{id:"docker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker","aria-hidden":"true"},"#"),l(" Docker")],-1),k=e("h2",{id:"初识-docker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#初识-docker","aria-hidden":"true"},"#"),l(" 初识 Docker")],-1),m=e("p",null,"我们写的代码会接触到好几个环境：开发环境、测试环境以及生产环境：",-1),_=["src"],b=["src"],v=e("h3",{id:"docker概念",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker概念","aria-hidden":"true"},"#"),l(" docker概念")],-1),f=e("p",null,"Docker 是一个开源的应用容器引擎 诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。 容器是完全使用沙箱机制，相互隔离 容器性能开销极低。 Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）",-1),g=e("h3",{id:"安装docker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#安装docker","aria-hidden":"true"},"#"),l(" 安装docker")],-1),D={href:"https://www.docker.com",target:"_blank",rel:"noopener noreferrer"},B=e("h3",{id:"docker架构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker架构","aria-hidden":"true"},"#"),l(" docker架构")],-1),w=e("p",null,[e("strong",null,"镜像（Image）"),l("：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。")],-1),x=e("p",null,[e("strong",null,"容器（Container）"),l("：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。")],-1),E=e("p",null,[e("strong",null,"仓库（Repository）"),l("：仓库可看成一个代码控制中心，用来保存镜像。")],-1),C=["src"],$=e("h3",{id:"配置-docker-镜像加速器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#配置-docker-镜像加速器","aria-hidden":"true"},"#"),l(" 配置 Docker 镜像加速器")],-1),M={href:"https://hub.docker.com/%EF%BC%89%E4%B8%8A%E4%B8%8B%E8%BD%BDdocker",target:"_blank",rel:"noopener noreferrer"},A={href:"https://docker.mirrors.ustc.edu.cn",target:"_blank",rel:"noopener noreferrer"},I=["src"],y=e("li",null,"网易云",-1),N=e("li",null,"腾讯云",-1),R=s('<h2 id="docker-命令" tabindex="-1"><a class="header-anchor" href="#docker-命令" aria-hidden="true">#</a> Docker 命令</h2><ul><li><p>Docker 进程相关命令</p><ul><li>启动docker服务 <ul><li>systemctl start docker</li></ul></li><li>停止docker服务 <ul><li>systemctl stop docker</li></ul></li><li>重启docker服务 <ul><li>systemctl restart docker</li></ul></li><li>查看docker服务状态 <ul><li>systemctl status docker</li></ul></li><li>开机启动docker服务 <ul><li>systemctl enable docker</li></ul></li></ul></li><li><p>Docker 镜像相关命令</p></li><li><p>查看镜像</p><ul><li>docker images</li><li>docker images –q # 查看所用镜像的id</li></ul></li><li><p>搜索镜像 : 从网络中查找需要的镜像</p><ul><li>docker search 镜像名称</li></ul></li><li><p>拉取镜像 : 从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。 docker pull 镜像名称</p></li><li><p>删除镜像 : 删除本地镜像</p><ul><li>docker rmi 镜像id # 删除指定本地镜像</li><li>docker rmi -f 镜像id</li><li>docker rmi <code>docker images -q</code> # 删除所有本地镜像</li></ul></li><li><p>Docker 容器相关命令</p></li><li><p>查看容器</p><ul><li>docker ps # 查看正在运行的容器</li><li>docker ps –a # 查看所有容器</li></ul></li><li><p>创建容器</p><ul><li><p>docker run 参数</p></li><li><p>docker run -it --name=c1 centos:7 /bin/bash</p></li><li><p>docker run -id --name=c1 centos:7</p></li></ul><p>参数说明：</p><ul><li>-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</li><li>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</li><li>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</li><li>--name：为创建的容器命名。</li></ul></li><li><p>进入容器</p><ul><li>docker exec 参数 # 退出容器，容器不会关闭</li><li>docker exec -it c2 /bin/bash</li><li>docker exec -it 容器ID /bin/bash</li></ul></li><li><p>启动容器</p><ul><li>docker start 容器名称</li></ul></li><li><p>停止容器</p><ul><li>docker stop 容器名称</li></ul></li><li><p>删除容器 ：如果容器是运行状态则删除失败，需要停止容器才能删除</p><ul><li>docker rm 容器名称</li></ul></li><li><p>查看容器信息</p><ul><li>docker inspect 容器名称</li></ul></li></ul><h2 id="docker-容器数据卷" tabindex="-1"><a class="header-anchor" href="#docker-容器数据卷" aria-hidden="true">#</a> Docker 容器数据卷</h2><h3 id="数据卷概念及作用" tabindex="-1"><a class="header-anchor" href="#数据卷概念及作用" aria-hidden="true">#</a> 数据卷概念及作用</h3><p>思考：</p><ul><li><p>Docker 容器删除后，在容器中产生的数据也会随之销毁</p></li><li><p>Docker 容器和外部机器可以直接交换文件吗？</p></li><li><p>容器之间想要进行数据交互？</p></li><li><p>数据卷</p><ul><li>数据卷是宿主机中的一个目录或文件</li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li><li>一个数据卷可以被多个容器同时挂载</li><li>一个容器也可以被挂载多个数据卷</li></ul></li><li><p>数据卷作用</p><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul></li></ul>',6),j=["src"],L=s(`<h3 id="配置数据卷" tabindex="-1"><a class="header-anchor" href="#配置数据卷" aria-hidden="true">#</a> 配置数据卷</h3><p>创建启动容器时，使用 –v 参数 设置数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token function">docker</span> run <span class="token punctuation">..</span>. –v 宿主机目录<span class="token punctuation">(</span>文件<span class="token punctuation">)</span>:容器内目录<span class="token punctuation">(</span>文件<span class="token punctuation">)</span> <span class="token punctuation">..</span>. 

  <span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c1 <span class="token parameter variable">-v</span> /root/data:/root/data_container centos:7 /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>注意事项： <ol><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ol></li></ul>`,4),U=["src"],O=e("h3",{id:"配置数据卷容器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#配置数据卷容器","aria-hidden":"true"},"#"),l(" 配置数据卷容器")],-1),S=e("p",null,"多容器进行数据交换",-1),T=e("ol",null,[e("li",null,"多个容器挂载同一个数据卷"),e("li",null,"数据卷容器")],-1),F=["src"],V=s(`<p>创建启动c3数据卷容器，使用 –v 参数 设置数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c3 –v /volume centos:7 /bin/bash 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c1 --volumes-from c3 centos:7 /bin/bash

<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c2 --volumes-from c3 centos:7 /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数据卷小结" tabindex="-1"><a class="header-anchor" href="#数据卷小结" aria-hidden="true">#</a> 数据卷小结</h3><ul><li>数据卷概念 <ul><li>宿主机的一个目录或文件</li></ul></li><li>数据卷作用 <ul><li>容器数据持久化</li><li>客户端和容器数据交换</li><li>容器间数据交换</li></ul></li><li>数据卷容器 <ul><li>创建一个容器，挂载一个目录，让其他容器继承自该容器( --volume-from )。</li><li>通过简单方式实现数据卷配置</li></ul></li></ul><h2 id="docker-应用部署" tabindex="-1"><a class="header-anchor" href="#docker-应用部署" aria-hidden="true">#</a> Docker 应用部署</h2><p>容器内的网络服务和外部机器不能直接通信 外部机器和宿主机可以直接通信 宿主机和容器可以直接通信 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而间接访问容器的服务。 这种操作称为：端口映射</p>`,8),G=["src"],q=e("h2",{id:"dockerfile",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dockerfile","aria-hidden":"true"},"#"),l(" Dockerfile")],-1),W=e("h3",{id:"docker-镜像原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker-镜像原理","aria-hidden":"true"},"#"),l(" Docker 镜像原理")],-1),K=e("p",null,"思考：",-1),z=e("ul",null,[e("li",null,"Docker 镜像本质是什么？"),e("li",null,"Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？"),e("li",null,"Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？")],-1),H=["src"],J=e("li",null,[e("p",null,"操作系统组成部分："),e("ul",null,[e("li",null,"进程调度子系统"),e("li",null,"进程通信子系统"),e("li",null,"内存管理子系统"),e("li",null,"设备管理子系统"),e("li",null,"文件管理子系统"),e("li",null,"网络通信子系统"),e("li",null,"作业控制子系统")])],-1),P=e("p",null,"Linux文件系统由bootfs和rootfs两部分组成",-1),Q=e("ul",null,[e("li",null,"bootfs：包含bootloader（引导加载程序）和 kernel（内核）"),e("li",null,"rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件"),e("li",null,"不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等")],-1),X=["src"],Y=e("li",null,[e("p",null,"Docker镜像是由特殊的文件系统叠加而成")],-1),Z=e("li",null,[e("p",null,"最底端是 bootfs，并使用宿主机的bootfs")],-1),ee=e("li",null,[e("p",null,"第二层是 root文件系统rootfs,称为base image")],-1),le=e("li",null,[e("p",null,"然后再往上可以叠加其他的镜像文件")],-1),ie=e("li",null,[e("p",null,"统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。")],-1),ne=e("li",null,[e("p",null,"一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。")],-1),se=e("p",null,"当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器",-1),oe=["src"],ae=e("li",null,[e("p",null,"思考："),e("ol",null,[e("li",null,"Docker 镜像本质是什么？ 是一个分层文件系统"),e("li",null,"Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层"),e("li",null,"Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB")])],-1),re=e("h3",{id:"镜像制作",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#镜像制作","aria-hidden":"true"},"#"),l(" 镜像制作")],-1),ce=e("p",null,"Docker 镜像如何制作？",-1),te=s(`<li><p>容器转为镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit 容器id 镜像名称:版本号

<span class="token function">docker</span> commit 4ae1c12213c7 docker_tomcat:1.0

<span class="token comment"># -------</span>

<span class="token function">docker</span> save <span class="token parameter variable">-o</span> 压缩文件名称 镜像名称:版本号

<span class="token function">docker</span> save <span class="token parameter variable">-o</span> docker_tomcat.tar docker_tomcat:1.0

<span class="token comment"># -------</span>

<span class="token function">docker</span> load –i 压缩文件名称

<span class="token function">docker</span> load <span class="token parameter variable">-i</span> docker_tomcat.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1),de=e("p",null,"dockerfile",-1),ue=e("li",null,[l("Dockerfile 概念 "),e("ul",null,[e("li",null,"Dockerfile 是一个文本文件"),e("li",null,"包含了一条条的指令"),e("li",null,"每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像"),e("li",null,"对于开发人员：可以为开发团队提供一个完全一致的开发环境"),e("li",null,"对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了"),e("li",null,"对于运维人员：在部署时，可以实现应用的无缝移植")])],-1),pe={href:"https://hub.docker.com",target:"_blank",rel:"noopener noreferrer"},he=["src"],ke=s(`<ul><li>Dockerfile 案例 <ul><li><p>需求 （centos7使用官方的，自己定义只是学习）</p><ul><li>自定义centos7镜像。要求： <ol><li>默认登录路径为 /usr</li><li>可以使用vim</li></ol></li></ul></li><li><p>实现步骤</p><ol><li>定义父镜像：FROM centos:7</li><li>定义作者信息：MAINTAINER itheima <a href="mailto:itheima@itcast.cn">itheima@itcast.cn</a></li><li>执行安装vim命令： RUN yum install -y vim</li><li>定义默认的工作目录：WORKDIR /usr</li><li>定义容器启动执行的命令：CMD /bin/bash</li><li>通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token comment"># 创建文件 将实现步骤添加到此文件中</span>
  <span class="token function">vim</span> docker-centos-file

  <span class="token comment"># 执行文件创建自定义镜像</span>
  <span class="token function">docker</span> build <span class="token parameter variable">-f</span> ./docker-centos-file <span class="token parameter variable">-t</span> han_centos:1 <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>需求</p><ul><li>定义dockerfile，发布springboot项目</li></ul></li><li><p>实现步骤</p><ul><li>定义父镜像：FROM java:8</li><li>定义作者信息：MAINTAINER itheima <a href="mailto:itheima@itcast.cn">itheima@itcast.cn</a></li><li>将jar包添加到容器： ADD springboot.jar app.jar</li><li>定义容器启动执行的命令：CMD java–jar app.jar</li><li>通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token comment"># 创建文件 将实现步骤添加到此文件中</span>
  <span class="token function">vim</span> springboot-dockerfile

  <span class="token comment"># 执行文件创建自定义镜像</span>
  <span class="token function">docker</span> build <span class="token parameter variable">-f</span> ./springboot-dockerfile <span class="token parameter variable">-t</span> app:1 <span class="token builtin class-name">.</span>

  <span class="token comment"># 执行镜像</span>
  <span class="token function">docker</span> run <span class="token parameter variable">-id</span> <span class="token parameter variable">-p</span> <span class="token number">9000</span>:8080 app:1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,1),me=s('<h2 id="docker-服务编排" tabindex="-1"><a class="header-anchor" href="#docker-服务编排" aria-hidden="true">#</a> Docker 服务编排</h2><h3 id="服务编排概念" tabindex="-1"><a class="header-anchor" href="#服务编排概念" aria-hidden="true">#</a> 服务编排概念</h3><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。</p><ul><li>要从Dockerfile build image 或者去dockerhub拉取image</li><li>要创建多个container</li><li>要管理这些container（启动停止删除）</li></ul><p><strong>服务编排:</strong> 按照一定的业务规则批量管理容器</p><h3 id="docker-compose-概述" tabindex="-1"><a class="header-anchor" href="#docker-compose-概述" aria-hidden="true">#</a> Docker Compose 概述</h3><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p><ol><li>利用 Dockerfile 定义运行环境镜像</li><li>使用 docker-compose.yml 定义组成应用的各服务</li><li>运行 docker-compose up 启动应用</li></ol>',8),_e=["src"],be=e("h2",{id:"docker-私有仓库",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker-私有仓库","aria-hidden":"true"},"#"),l(" Docker 私有仓库")],-1),ve={href:"https://hub.docker.com",target:"_blank",rel:"noopener noreferrer"},fe=e("h2",{id:"docker相关概念",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker相关概念","aria-hidden":"true"},"#"),l(" Docker相关概念")],-1),ge=e("h3",{id:"docker容器虚拟化-与-传统虚拟机比较",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker容器虚拟化-与-传统虚拟机比较","aria-hidden":"true"},"#"),l(" docker容器虚拟化 与 传统虚拟机比较")],-1),De=e("p",null,"容器就是将软件打包成标准化单元，以用于开发、交付和部署。",-1),Be=e("li",null,[e("p",null,"容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。")],-1),we=e("li",null,[e("p",null,"容器化软件在任何环境中都能够始终如一地运行。")],-1),xe=e("p",null,"容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。",-1),Ee=["src"],Ce=e("li",null,[e("p",null,"相同："),e("ul",null,[e("li",null,"容器和虚拟机具有相似的资源隔离和分配优势")])],-1),$e=e("p",null,"不同：",-1),Me=e("ul",null,[e("li",null,"容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。"),e("li",null,"传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统")],-1),Ae=["src"],Ie=["src"];function ye(i,Ne){const o=c("ExternalLinkIcon"),a=c("RouterLink");return d(),u("div",null,[h,k,m,e("img",{src:i.$withBase("/docker/01.png"),alt:"foo"},null,8,_),e("img",{src:i.$withBase("/docker/02.png"),alt:"foo"},null,8,b),v,f,g,e("p",null,[l("Docker可以运行在MAC、Windows、CentOS、UBUNTU等操作系统上，本课程基于CentOS 7 安装Docker。官网："),e("a",D,[l("https://www.docker.com"),n(o)])]),B,w,x,E,e("img",{src:i.$withBase("/docker/03.png"),alt:"foo"},null,8,C),$,e("p",null,[l("默认情况下，将来从docker hub（"),e("a",M,[l("https://hub.docker.com/）上下载docker"),n(o)]),l("镜像，太慢。一般都会配置镜像加速器：")]),e("ul",null,[e("li",null,[l("USTC：中科大镜像加速器（"),e("a",A,[l("https://docker.mirrors.ustc.edu.cn"),n(o)]),l("）")]),e("li",null,[l("阿里云 （每个人的加速器都是不一样的） "),e("img",{src:i.$withBase("/docker/04.png"),alt:"foo"},null,8,I)]),y,N]),R,e("img",{src:i.$withBase("/docker/05.png"),alt:"foo"},null,8,j),L,e("img",{src:i.$withBase("/docker/06.png"),alt:"foo"},null,8,U),O,S,T,e("img",{src:i.$withBase("/docker/07.png"),alt:"foo"},null,8,F),V,e("img",{src:i.$withBase("/docker/09.png"),alt:"foo"},null,8,G),e("p",null,[n(a,{to:"/views/Docker/docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2.html"},{default:r(()=>[l("docker应用部署")]),_:1})]),q,W,e("ul",null,[e("li",null,[K,z,e("img",{src:i.$withBase("/docker/10.png"),alt:"foo"},null,8,H)]),J,e("li",null,[P,Q,e("img",{src:i.$withBase("/docker/11.png"),alt:"foo"},null,8,X)]),Y,Z,ee,le,ie,ne,e("li",null,[se,e("img",{src:i.$withBase("/docker/12.png"),alt:"foo"},null,8,oe)]),ae]),re,ce,e("ul",null,[te,e("li",null,[de,e("ul",null,[ue,e("li",null,[l("Dochub网址："),e("a",pe,[l("https://hub.docker.com"),n(o)])])]),e("img",{src:i.$withBase("/docker/13.png"),alt:"foo"},null,8,he),e("p",null,[n(a,{to:"/views/Docker/dockerfile.html"},{default:r(()=>[l("Dockerfile 关键字")]),_:1})]),ke])]),me,e("img",{src:i.$withBase("/docker/14.png"),alt:"foo"},null,8,_e),e("p",null,[n(a,{to:"/views/Docker/docker-compose.html"},{default:r(()=>[l("DockerCompose")]),_:1})]),be,e("p",null,[l("Docker官方的Docker hub（"),e("a",ve,[l("https://hub.docker.com"),n(o)]),l("）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜 像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。")]),e("p",null,[n(a,{to:"/views/Docker/docker%20%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html"},{default:r(()=>[l("私有仓库")]),_:1})]),fe,ge,De,e("ul",null,[Be,we,e("li",null,[xe,e("img",{src:i.$withBase("/docker/15.png"),alt:"foo"},null,8,Ee)]),Ce,e("li",null,[$e,Me,e("img",{src:i.$withBase("/docker/16.png"),alt:"foo"},null,8,Ae),e("img",{src:i.$withBase("/docker/17.png"),alt:"foo"},null,8,Ie)])])])}const je=t(p,[["render",ye],["__file","docker.html.vue"]]);export{je as default};
