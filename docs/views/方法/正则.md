# 正则

## 元字符
字符 | 描述 
- | :-: 
\d | 匹配一个数字字符。等价于 [0-9]
\D | 匹配一个非数字字符。等价于 [^0-9]
\w | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'
\W | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'
\s | 匹配任何空白字符，包括空格、制表符、换页符
\S | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]
\f | 匹配一个换页符
\n | 匹配一个换行符
\r | 匹配一个回车符
\t | 匹配一个制表符
\v | 匹配一个垂直制表符
^ | 匹配输入字符串开始的位置
$ | 匹配输入字符串结尾的位置
\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'
\B | 与 \b 相反：er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'
. | 匹配除换行符（\n、\r）之外的任何单个字符


## 区间

字符 | 描述 
- | :-: 
[0-9] | 匹配 0-9 之间的数字
[A-Z] | 匹配 A-Z 之间的字母，也可以组合 [A-Za-z0-9]

## 限定符

字符 | 描述 
- | :-: 
* | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}
+ | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}
? | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}
{n} | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o
{n,} | 	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'
{n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格

## 转义
但由于符号 /、.、(、) 等等在正则是特殊字符，所以需要用转义符 \ 转义

## 贪婪

字符 | 描述 
- | :-: 
*? | 重复多次，但尽可能少重复
+? | 重复1次、多次，但尽可能少重复
?? | 重复0次、1次，但尽可能少重复
{n,m}? | 重复n~m次，但尽可能少重复
{n,}? | 重复n次以上，但尽可能少重复

## 常用方法
- test()
  - 规则：正则表达式搜索字符串指定的值，从而去匹配字符串。如果匹配成功就返回 true，如果匹配失败就返回 false。
  - 用法：正则.test(字符串)
  - 案例：
    ```js
    var str = "123abc";
    var re = /\D/; // 匹配非数字
    if(re.test(str)) {
      console.log("不全是数字！");
    } else {
      console.log("全是数字！"); // 正确
    }
    ```

- search()
  - 规则：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1
  - 用法：字符串.search(正则)
  - 案例：
    ```js
    var str = "abcdef";
    var re1 = /d/i;
    var re2 = /h/i;
    console.log(str.search(re1)); // 3
    console.log(str.search(re2)); // -1
    ```

- match()
  - 规则：正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成，就返回 null
  - 用法：字符串.match(正则)
  - 案例：
    ```js
    var str = "123fadf321dfadf4fadf1"; //(4) ["123", "321", "4", "1"]
    var re = /\d+/g;
    console.log(str.match(re)); // ["123", "321", "4", "1"]
    ```

- exec()
  - 规则：将返回一个数组，其中存放匹配的结果。如果为找到匹配结果，则返回 null。
  - 用法：字符串.exec(正则)
  - `全局匹配时，match会返回所有匹配上的内容；而exec仅匹配单次匹配上的内容 全局匹配且进行多次匹配时，exe会从上次匹配结束的下一位开始匹配，返回本次匹配上的内容，直至无可以匹配的内容，返回null`
  - 案例：
    ```js
    var str = "123fadf321dfadf4fadf1"; //(4) ["123", "321", "4", "1"]
    var re = /\d+/g;
    console.log(str.match(re)); // ["123", "321", "4", "1"]
    ```

- replace()
  - 规则：正则去匹配字符串，匹配成功的字符串去替换成新的字符串。函数的第一个参数，是匹配成功的字符；第二个参数：可以是字符串，也可以是一个回调函数。
  - 用法：字符串.replace(正则,新的字符串)
  - 案例：
    ```js
    var str = 'aaa';
    var re = /a+/g;
    str = str.replace(re, "b");
    console.log(str); // b
    ```

- RegExp
  - 语法: new RegExp(pattern[, flags])
  - 参数 pattern 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.
  - 参数 flags 是一个可选的字符串, 包含属性 “g”、”i” 和 “m”, 分别用于指定全局匹配、区分大小写的匹配和多行匹配. 如果pattern 是正则表达式, 而不是字符串, 则必须省略该参数.
  - 案例：
    ```js
    var str = 'esfsesfsfsdgfsd1234'
    var pattern = "[0-9]";
    var reg = new RegExp(pattern,"g");
    // 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种
    var reg = /[0-9]/g;
    
    str.replace(reg, '这些是数字')
    ```

